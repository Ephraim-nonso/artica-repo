{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatAbiParameter = void 0;\nconst regex_js_1 = require(\"../regex.js\");\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\nfunction formatAbiParameter(abiParameter) {\n  let type = abiParameter.type;\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '(';\n    const length = abiParameter.components.length;\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i];\n      type += formatAbiParameter(component);\n      if (i < length - 1) type += ', ';\n    }\n    const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);\n    type += `)${result?.array ?? ''}`;\n    return formatAbiParameter({\n      ...abiParameter,\n      type\n    });\n  }\n  if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;\n  if (abiParameter.name) return `${type} ${abiParameter.name}`;\n  return type;\n}\nexports.formatAbiParameter = formatAbiParameter;","map":{"version":3,"names":["regex_js_1","require","tupleRegex","formatAbiParameter","abiParameter","type","test","length","components","i","component","result","execTyped","array","indexed","name","exports"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\Artica\\artica-repo\\frontend\\node_modules\\abitype\\src\\human-readable\\formatAbiParameter.ts"],"sourcesContent":["import type { AbiEventParameter, AbiParameter } from '../abi.js'\r\nimport { execTyped } from '../regex.js'\r\nimport type { IsNarrowable, Join } from '../types.js'\r\n\r\n/**\r\n * Formats {@link AbiParameter} to human-readable ABI parameter.\r\n *\r\n * @param TAbiParameter - ABI parameter\r\n * @returns Human-readable ABI parameter\r\n *\r\n * @example\r\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\r\n * //   ^? type Result = 'address from'\r\n */\r\nexport type FormatAbiParameter<\r\n  TAbiParameter extends AbiParameter | AbiEventParameter,\r\n> = TAbiParameter extends {\r\n  name?: infer Name extends string\r\n  type: `tuple${infer Array}`\r\n  components: infer Components extends readonly AbiParameter[]\r\n  indexed?: infer Indexed extends boolean\r\n}\r\n  ? FormatAbiParameter<\r\n      {\r\n        type: `(${Join<\r\n          {\r\n            [K in keyof Components]: FormatAbiParameter<\r\n              {\r\n                type: Components[K]['type']\r\n              } & (IsNarrowable<Components[K]['name'], string> extends true\r\n                ? { name: Components[K]['name'] }\r\n                : unknown) &\r\n                (Components[K] extends { components: readonly AbiParameter[] }\r\n                  ? { components: Components[K]['components'] }\r\n                  : unknown)\r\n            >\r\n          },\r\n          ', '\r\n        >})${Array}`\r\n      } & (IsNarrowable<Name, string> extends true ? { name: Name } : unknown) &\r\n        (IsNarrowable<Indexed, boolean> extends true\r\n          ? { indexed: Indexed }\r\n          : unknown)\r\n    >\r\n  : `${TAbiParameter['type']}${TAbiParameter extends { indexed: true }\r\n      ? ' indexed'\r\n      : ''}${TAbiParameter['name'] extends infer Name extends string\r\n      ? ` ${Name}`\r\n      : ''}`\r\n\r\n// https://regexr.com/7f7rv\r\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\r\n\r\n/**\r\n * Formats {@link AbiParameter} to human-readable ABI parameter.\r\n *\r\n * @param abiParameter - ABI parameter\r\n * @returns Human-readable ABI parameter\r\n *\r\n * @example\r\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\r\n * //    ^? const result: 'address from'\r\n */\r\nexport function formatAbiParameter<\r\n  const TAbiParameter extends AbiParameter | AbiEventParameter,\r\n>(abiParameter: TAbiParameter): FormatAbiParameter<TAbiParameter> {\r\n  type Result = FormatAbiParameter<TAbiParameter>\r\n\r\n  let type = abiParameter.type\r\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\r\n    type = '('\r\n    const length = abiParameter.components.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const component = abiParameter.components[i]!\r\n      type += formatAbiParameter(component)\r\n      if (i < length - 1) type += ', '\r\n    }\r\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\r\n    type += `)${result?.array ?? ''}`\r\n    return formatAbiParameter({\r\n      ...abiParameter,\r\n      type,\r\n    }) as Result\r\n  }\r\n  // Add `indexed` to type if in `abiParameter`\r\n  if ('indexed' in abiParameter && abiParameter.indexed)\r\n    type = `${type} indexed`\r\n  // Return human-readable ABI parameter\r\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\r\n  return type as Result\r\n}\r\n"],"mappings":";;;;;;AACA,MAAAA,UAAA,GAAAC,OAAA;AAkDA,MAAMC,UAAU,GAAG,+BAA+B;AAYlD,SAAgBC,kBAAkBA,CAEhCC,YAA2B;EAG3B,IAAIC,IAAI,GAAGD,YAAY,CAACC,IAAI;EAC5B,IAAIH,UAAU,CAACI,IAAI,CAACF,YAAY,CAACC,IAAI,CAAC,IAAI,YAAY,IAAID,YAAY,EAAE;IACtEC,IAAI,GAAG,GAAG;IACV,MAAME,MAAM,GAAGH,YAAY,CAACI,UAAU,CAACD,MAAgB;IACvD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC/B,MAAMC,SAAS,GAAGN,YAAY,CAACI,UAAU,CAACC,CAAC,CAAE;MAC7CJ,IAAI,IAAIF,kBAAkB,CAACO,SAAS,CAAC;MACrC,IAAID,CAAC,GAAGF,MAAM,GAAG,CAAC,EAAEF,IAAI,IAAI,IAAI;;IAElC,MAAMM,MAAM,GAAG,IAAAX,UAAA,CAAAY,SAAS,EAAqBV,UAAU,EAAEE,YAAY,CAACC,IAAI,CAAC;IAC3EA,IAAI,IAAI,IAAIM,MAAM,EAAEE,KAAK,IAAI,EAAE,EAAE;IACjC,OAAOV,kBAAkB,CAAC;MACxB,GAAGC,YAAY;MACfC;KACD,CAAW;;EAGd,IAAI,SAAS,IAAID,YAAY,IAAIA,YAAY,CAACU,OAAO,EACnDT,IAAI,GAAG,GAAGA,IAAI,UAAU;EAE1B,IAAID,YAAY,CAACW,IAAI,EAAE,OAAO,GAAGV,IAAI,IAAID,YAAY,CAACW,IAAI,EAAY;EACtE,OAAOV,IAAc;AACvB;AA3BAW,OAAA,CAAAb,kBAAA,GAAAA,kBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}