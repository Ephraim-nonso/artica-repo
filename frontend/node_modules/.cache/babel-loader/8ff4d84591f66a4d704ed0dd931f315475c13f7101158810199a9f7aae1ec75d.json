{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseStructs = void 0;\nconst regex_js_1 = require(\"../../regex.js\");\nconst abiItem_js_1 = require(\"../errors/abiItem.js\");\nconst abiParameter_js_1 = require(\"../errors/abiParameter.js\");\nconst signature_js_1 = require(\"../errors/signature.js\");\nconst struct_js_1 = require(\"../errors/struct.js\");\nconst signatures_js_1 = require(\"./signatures.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!(0, signatures_js_1.isStructSignature)(signature)) continue;\n    const match = (0, signatures_js_1.execStructSignature)(signature);\n    if (!match) throw new signature_js_1.InvalidSignatureError({\n      signature,\n      type: 'struct'\n    });\n    const properties = match.properties.split(';');\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {\n        type: 'struct'\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new signature_js_1.InvalidStructSignatureError({\n      signature\n    });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i];\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nexports.parseStructs = parseStructs;\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);\n      if (!match?.type) throw new abiParameter_js_1.InvalidAbiTypeParameterError({\n        abiParameter\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        if (ancestors.has(type)) throw new struct_js_1.CircularReferenceError({\n          type\n        });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))\n        });\n      } else {\n        if ((0, utils_js_1.isSolidityType)(type)) components.push(abiParameter);else throw new abiItem_js_1.UnknownTypeError({\n          type\n        });\n      }\n    }\n  }\n  return components;\n}","map":{"version":3,"names":["regex_js_1","require","abiItem_js_1","abiParameter_js_1","signature_js_1","struct_js_1","signatures_js_1","utils_js_1","parseStructs","signatures","shallowStructs","signaturesLength","length","i","signature","isStructSignature","match","execStructSignature","InvalidSignatureError","type","properties","split","components","propertiesLength","k","property","trimmed","trim","abiParameter","parseAbiParameter","push","InvalidStructSignatureError","name","resolvedStructs","entries","Object","entriesLength","parameters","resolveStructs","exports","typeWithoutTupleRegex","abiParameters","structs","ancestors","Set","isTuple","isTupleRegex","test","execTyped","InvalidAbiTypeParameterError","array","has","CircularReferenceError","isSolidityType","UnknownTypeError"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\Artica\\artica-repo\\frontend\\node_modules\\abitype\\src\\human-readable\\runtime\\structs.ts"],"sourcesContent":["import type { AbiParameter } from '../../abi.js'\r\nimport { execTyped, isTupleRegex } from '../../regex.js'\r\nimport { UnknownTypeError } from '../errors/abiItem.js'\r\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\r\nimport {\r\n  InvalidSignatureError,\r\n  InvalidStructSignatureError,\r\n} from '../errors/signature.js'\r\nimport { CircularReferenceError } from '../errors/struct.js'\r\nimport type { StructLookup } from '../types/structs.js'\r\nimport { execStructSignature, isStructSignature } from './signatures.js'\r\nimport { isSolidityType, parseAbiParameter } from './utils.js'\r\n\r\nexport function parseStructs(signatures: readonly string[]) {\r\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\r\n  const shallowStructs: StructLookup = {}\r\n  const signaturesLength = signatures.length\r\n  for (let i = 0; i < signaturesLength; i++) {\r\n    const signature = signatures[i]!\r\n    if (!isStructSignature(signature)) continue\r\n\r\n    const match = execStructSignature(signature)\r\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\r\n\r\n    const properties = match.properties.split(';')\r\n\r\n    const components: AbiParameter[] = []\r\n    const propertiesLength = properties.length\r\n    for (let k = 0; k < propertiesLength; k++) {\r\n      const property = properties[k]!\r\n      const trimmed = property.trim()\r\n      if (!trimmed) continue\r\n      const abiParameter = parseAbiParameter(trimmed, {\r\n        type: 'struct',\r\n      })\r\n      components.push(abiParameter)\r\n    }\r\n\r\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\r\n    shallowStructs[match.name] = components\r\n  }\r\n\r\n  // Resolve nested structs inside each parameter\r\n  const resolvedStructs: StructLookup = {}\r\n  const entries = Object.entries(shallowStructs)\r\n  const entriesLength = entries.length\r\n  for (let i = 0; i < entriesLength; i++) {\r\n    const [name, parameters] = entries[i]!\r\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\r\n  }\r\n\r\n  return resolvedStructs\r\n}\r\n\r\nconst typeWithoutTupleRegex =\r\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\r\n\r\nfunction resolveStructs(\r\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\r\n  structs: StructLookup,\r\n  ancestors = new Set<string>(),\r\n) {\r\n  const components: AbiParameter[] = []\r\n  const length = abiParameters.length\r\n  for (let i = 0; i < length; i++) {\r\n    const abiParameter = abiParameters[i]!\r\n    const isTuple = isTupleRegex.test(abiParameter.type)\r\n    if (isTuple) components.push(abiParameter)\r\n    else {\r\n      const match = execTyped<{ array?: string; type: string }>(\r\n        typeWithoutTupleRegex,\r\n        abiParameter.type,\r\n      )\r\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\r\n\r\n      const { array, type } = match\r\n      if (type in structs) {\r\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\r\n\r\n        components.push({\r\n          ...abiParameter,\r\n          type: `tuple${array ?? ''}`,\r\n          components: resolveStructs(\r\n            structs[type] ?? [],\r\n            structs,\r\n            new Set([...ancestors, type]),\r\n          ),\r\n        })\r\n      } else {\r\n        if (isSolidityType(type)) components.push(abiParameter)\r\n        else throw new UnknownTypeError({ type })\r\n      }\r\n    }\r\n  }\r\n\r\n  return components\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}