{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;\nconst regex_js_1 = require(\"../../regex.js\");\nconst abiItem_js_1 = require(\"../errors/abiItem.js\");\nconst abiParameter_js_1 = require(\"../errors/abiParameter.js\");\nconst signature_js_1 = require(\"../errors/signature.js\");\nconst splitParameters_js_1 = require(\"../errors/splitParameters.js\");\nconst cache_js_1 = require(\"./cache.js\");\nconst signatures_js_1 = require(\"./signatures.js\");\nfunction parseSignature(signature, structs = {}) {\n  if ((0, signatures_js_1.isFunctionSignature)(signature)) {\n    const match = (0, signatures_js_1.execFunctionSignature)(signature);\n    if (!match) throw new signature_js_1.InvalidSignatureError({\n      signature,\n      type: 'function'\n    });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(parseAbiParameter(inputParams[i], {\n        modifiers: signatures_js_1.functionModifiers,\n        structs,\n        type: 'function'\n      }));\n    }\n    const outputs = [];\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(parseAbiParameter(outputParams[i], {\n          modifiers: signatures_js_1.functionModifiers,\n          structs,\n          type: 'function'\n        }));\n      }\n    }\n    return {\n      name: match.name,\n      type: 'function',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs,\n      outputs\n    };\n  }\n  if ((0, signatures_js_1.isEventSignature)(signature)) {\n    const match = (0, signatures_js_1.execEventSignature)(signature);\n    if (!match) throw new signature_js_1.InvalidSignatureError({\n      signature,\n      type: 'event'\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        modifiers: signatures_js_1.eventModifiers,\n        structs,\n        type: 'event'\n      }));\n    }\n    return {\n      name: match.name,\n      type: 'event',\n      inputs: abiParameters\n    };\n  }\n  if ((0, signatures_js_1.isErrorSignature)(signature)) {\n    const match = (0, signatures_js_1.execErrorSignature)(signature);\n    if (!match) throw new signature_js_1.InvalidSignatureError({\n      signature,\n      type: 'error'\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: 'error'\n      }));\n    }\n    return {\n      name: match.name,\n      type: 'error',\n      inputs: abiParameters\n    };\n  }\n  if ((0, signatures_js_1.isConstructorSignature)(signature)) {\n    const match = (0, signatures_js_1.execConstructorSignature)(signature);\n    if (!match) throw new signature_js_1.InvalidSignatureError({\n      signature,\n      type: 'constructor'\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: 'constructor'\n      }));\n    }\n    return {\n      type: 'constructor',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs: abiParameters\n    };\n  }\n  if ((0, signatures_js_1.isFallbackSignature)(signature)) return {\n    type: 'fallback'\n  };\n  if ((0, signatures_js_1.isReceiveSignature)(signature)) return {\n    type: 'receive',\n    stateMutability: 'payable'\n  };\n  throw new signature_js_1.UnknownSignatureError({\n    signature\n  });\n}\nexports.parseSignature = parseSignature;\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);\n  if (cache_js_1.parameterCache.has(parameterCacheKey)) return cache_js_1.parameterCache.get(parameterCacheKey);\n  const isTuple = regex_js_1.isTupleRegex.test(param);\n  const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new abiParameter_js_1.InvalidParameterError({\n    param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new abiParameter_js_1.SolidityProtectedKeywordError({\n    param,\n    name: match.name\n  });\n  const name = match.name ? {\n    name: match.name\n  } : {};\n  const indexed = match.modifier === 'indexed' ? {\n    indexed: true\n  } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = 'tuple';\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], {\n        structs\n      }));\n    }\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = 'tuple';\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === 'struct') && !isSolidityType(type)) throw new abiItem_js_1.UnknownSolidityTypeError({\n      type\n    });\n  }\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier)) throw new abiParameter_js_1.InvalidModifierError({\n      param,\n      type: options?.type,\n      modifier: match.modifier\n    });\n    if (signatures_js_1.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new abiParameter_js_1.InvalidFunctionModifierError({\n      param,\n      type: options?.type,\n      modifier: match.modifier\n    });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components\n  };\n  cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nexports.parseAbiParameter = parseAbiParameter;\nfunction splitParameters(params, result = [], current = '', depth = 0) {\n  if (params === '') {\n    if (current === '') return result;\n    if (depth !== 0) throw new splitParameters_js_1.InvalidParenthesisError({\n      current,\n      depth\n    });\n    result.push(current.trim());\n    return result;\n  }\n  const length = params.length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case ',':\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  return [];\n}\nexports.splitParameters = splitParameters;\nfunction isSolidityType(type) {\n  return type === 'address' || type === 'bool' || type === 'function' || type === 'string' || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);\n}\nexports.isSolidityType = isSolidityType;\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name) {\n  return name === 'address' || name === 'bool' || name === 'function' || name === 'string' || name === 'tuple' || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);\n}\nexports.isSolidityKeyword = isSolidityKeyword;\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\nexports.isValidDataLocation = isValidDataLocation;","map":{"version":3,"names":["regex_js_1","require","abiItem_js_1","abiParameter_js_1","signature_js_1","splitParameters_js_1","cache_js_1","signatures_js_1","parseSignature","signature","structs","isFunctionSignature","match","execFunctionSignature","InvalidSignatureError","type","inputParams","splitParameters","parameters","inputs","inputLength","length","i","push","parseAbiParameter","modifiers","functionModifiers","outputs","returns","outputParams","outputLength","name","stateMutability","isEventSignature","execEventSignature","params","abiParameters","eventModifiers","isErrorSignature","execErrorSignature","isConstructorSignature","execConstructorSignature","isFallbackSignature","isReceiveSignature","UnknownSignatureError","exports","abiParameterWithoutTupleRegex","abiParameterWithTupleRegex","dynamicIntegerRegex","param","options","parameterCacheKey","getParameterCacheKey","parameterCache","has","get","isTuple","isTupleRegex","test","execTyped","InvalidParameterError","isSolidityKeyword","SolidityProtectedKeywordError","indexed","modifier","components","components_","isSolidityType","UnknownSolidityTypeError","InvalidModifierError","isValidDataLocation","array","InvalidFunctionModifierError","abiParameter","set","result","current","depth","InvalidParenthesisError","trim","char","tail","slice","bytesRegex","integerRegex","protectedKeywordsRegex","isArray"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\Artica\\artica-repo\\frontend\\node_modules\\abitype\\src\\human-readable\\runtime\\utils.ts"],"sourcesContent":["import type {\r\n  AbiItemType,\r\n  AbiType,\r\n  SolidityArray,\r\n  SolidityBytes,\r\n  SolidityString,\r\n  SolidityTuple,\r\n} from '../../abi.js'\r\nimport {\r\n  bytesRegex,\r\n  execTyped,\r\n  integerRegex,\r\n  isTupleRegex,\r\n} from '../../regex.js'\r\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\r\nimport {\r\n  InvalidFunctionModifierError,\r\n  InvalidModifierError,\r\n  InvalidParameterError,\r\n  SolidityProtectedKeywordError,\r\n} from '../errors/abiParameter.js'\r\nimport {\r\n  InvalidSignatureError,\r\n  UnknownSignatureError,\r\n} from '../errors/signature.js'\r\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\r\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\r\nimport type { StructLookup } from '../types/structs.js'\r\nimport { getParameterCacheKey, parameterCache } from './cache.js'\r\nimport {\r\n  eventModifiers,\r\n  execConstructorSignature,\r\n  execErrorSignature,\r\n  execEventSignature,\r\n  execFunctionSignature,\r\n  functionModifiers,\r\n  isConstructorSignature,\r\n  isErrorSignature,\r\n  isEventSignature,\r\n  isFallbackSignature,\r\n  isFunctionSignature,\r\n  isReceiveSignature,\r\n} from './signatures.js'\r\n\r\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\r\n  if (isFunctionSignature(signature)) {\r\n    const match = execFunctionSignature(signature)\r\n    if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\r\n\r\n    const inputParams = splitParameters(match.parameters)\r\n    const inputs = []\r\n    const inputLength = inputParams.length\r\n    for (let i = 0; i < inputLength; i++) {\r\n      inputs.push(\r\n        parseAbiParameter(inputParams[i]!, {\r\n          modifiers: functionModifiers,\r\n          structs,\r\n          type: 'function',\r\n        }),\r\n      )\r\n    }\r\n\r\n    const outputs = []\r\n    if (match.returns) {\r\n      const outputParams = splitParameters(match.returns)\r\n      const outputLength = outputParams.length\r\n      for (let i = 0; i < outputLength; i++) {\r\n        outputs.push(\r\n          parseAbiParameter(outputParams[i]!, {\r\n            modifiers: functionModifiers,\r\n            structs,\r\n            type: 'function',\r\n          }),\r\n        )\r\n      }\r\n    }\r\n\r\n    return {\r\n      name: match.name,\r\n      type: 'function',\r\n      stateMutability: match.stateMutability ?? 'nonpayable',\r\n      inputs,\r\n      outputs,\r\n    }\r\n  }\r\n\r\n  if (isEventSignature(signature)) {\r\n    const match = execEventSignature(signature)\r\n    if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\r\n\r\n    const params = splitParameters(match.parameters)\r\n    const abiParameters = []\r\n    const length = params.length\r\n    for (let i = 0; i < length; i++) {\r\n      abiParameters.push(\r\n        parseAbiParameter(params[i]!, {\r\n          modifiers: eventModifiers,\r\n          structs,\r\n          type: 'event',\r\n        }),\r\n      )\r\n    }\r\n    return { name: match.name, type: 'event', inputs: abiParameters }\r\n  }\r\n\r\n  if (isErrorSignature(signature)) {\r\n    const match = execErrorSignature(signature)\r\n    if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\r\n\r\n    const params = splitParameters(match.parameters)\r\n    const abiParameters = []\r\n    const length = params.length\r\n    for (let i = 0; i < length; i++) {\r\n      abiParameters.push(\r\n        parseAbiParameter(params[i]!, { structs, type: 'error' }),\r\n      )\r\n    }\r\n    return { name: match.name, type: 'error', inputs: abiParameters }\r\n  }\r\n\r\n  if (isConstructorSignature(signature)) {\r\n    const match = execConstructorSignature(signature)\r\n    if (!match)\r\n      throw new InvalidSignatureError({ signature, type: 'constructor' })\r\n\r\n    const params = splitParameters(match.parameters)\r\n    const abiParameters = []\r\n    const length = params.length\r\n    for (let i = 0; i < length; i++) {\r\n      abiParameters.push(\r\n        parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\r\n      )\r\n    }\r\n    return {\r\n      type: 'constructor',\r\n      stateMutability: match.stateMutability ?? 'nonpayable',\r\n      inputs: abiParameters,\r\n    }\r\n  }\r\n\r\n  if (isFallbackSignature(signature)) return { type: 'fallback' }\r\n  if (isReceiveSignature(signature))\r\n    return {\r\n      type: 'receive',\r\n      stateMutability: 'payable',\r\n    }\r\n\r\n  throw new UnknownSignatureError({ signature })\r\n}\r\n\r\nconst abiParameterWithoutTupleRegex =\r\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\r\nconst abiParameterWithTupleRegex =\r\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\r\nconst dynamicIntegerRegex = /^u?int$/\r\n\r\ntype ParseOptions = {\r\n  modifiers?: Set<Modifier>\r\n  structs?: StructLookup\r\n  type?: AbiItemType | 'struct'\r\n}\r\n\r\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\r\n  // optional namespace cache by `type`\r\n  const parameterCacheKey = getParameterCacheKey(param, options?.type)\r\n  if (parameterCache.has(parameterCacheKey))\r\n    return parameterCache.get(parameterCacheKey)!\r\n\r\n  const isTuple = isTupleRegex.test(param)\r\n  const match = execTyped<{\r\n    array?: string\r\n    modifier?: Modifier\r\n    name?: string\r\n    type: string\r\n  }>(\r\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\r\n    param,\r\n  )\r\n  if (!match) throw new InvalidParameterError({ param })\r\n\r\n  if (match.name && isSolidityKeyword(match.name))\r\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\r\n\r\n  const name = match.name ? { name: match.name } : {}\r\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\r\n  const structs = options?.structs ?? {}\r\n  let type: string\r\n  let components = {}\r\n  if (isTuple) {\r\n    type = 'tuple'\r\n    const params = splitParameters(match.type)\r\n    const components_ = []\r\n    const length = params.length\r\n    for (let i = 0; i < length; i++) {\r\n      // remove `modifiers` from `options` to prevent from being added to tuple components\r\n      components_.push(parseAbiParameter(params[i]!, { structs }))\r\n    }\r\n    components = { components: components_ }\r\n  } else if (match.type in structs) {\r\n    type = 'tuple'\r\n    components = { components: structs[match.type] }\r\n  } else if (dynamicIntegerRegex.test(match.type)) {\r\n    type = `${match.type}256`\r\n  } else {\r\n    type = match.type\r\n    if (!(options?.type === 'struct') && !isSolidityType(type))\r\n      throw new UnknownSolidityTypeError({ type })\r\n  }\r\n\r\n  if (match.modifier) {\r\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\r\n    if (!options?.modifiers?.has?.(match.modifier))\r\n      throw new InvalidModifierError({\r\n        param,\r\n        type: options?.type,\r\n        modifier: match.modifier,\r\n      })\r\n\r\n    // Check if resolved `type` is valid if there is a function modifier\r\n    if (\r\n      functionModifiers.has(match.modifier as FunctionModifier) &&\r\n      !isValidDataLocation(type, !!match.array)\r\n    )\r\n      throw new InvalidFunctionModifierError({\r\n        param,\r\n        type: options?.type,\r\n        modifier: match.modifier,\r\n      })\r\n  }\r\n\r\n  const abiParameter = {\r\n    type: `${type}${match.array ?? ''}`,\r\n    ...name,\r\n    ...indexed,\r\n    ...components,\r\n  }\r\n  parameterCache.set(parameterCacheKey, abiParameter)\r\n  return abiParameter\r\n}\r\n\r\n// s/o latika for this\r\nexport function splitParameters(\r\n  params: string,\r\n  result: string[] = [],\r\n  current = '',\r\n  depth = 0,\r\n): readonly string[] {\r\n  if (params === '') {\r\n    if (current === '') return result\r\n    if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\r\n\r\n    result.push(current.trim())\r\n    return result\r\n  }\r\n\r\n  const length = params.length\r\n  // rome-ignore lint/correctness/noUnreachable: recursive\r\n  for (let i = 0; i < length; i++) {\r\n    const char = params[i]\r\n    const tail = params.slice(i + 1)\r\n    switch (char) {\r\n      case ',':\r\n        return depth === 0\r\n          ? splitParameters(tail, [...result, current.trim()])\r\n          : splitParameters(tail, result, `${current}${char}`, depth)\r\n      case '(':\r\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\r\n      case ')':\r\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\r\n      default:\r\n        return splitParameters(tail, result, `${current}${char}`, depth)\r\n    }\r\n  }\r\n\r\n  return []\r\n}\r\n\r\nexport function isSolidityType(\r\n  type: string,\r\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\r\n  return (\r\n    type === 'address' ||\r\n    type === 'bool' ||\r\n    type === 'function' ||\r\n    type === 'string' ||\r\n    bytesRegex.test(type) ||\r\n    integerRegex.test(type)\r\n  )\r\n}\r\n\r\nconst protectedKeywordsRegex =\r\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\r\n\r\nexport function isSolidityKeyword(name: string) {\r\n  return (\r\n    name === 'address' ||\r\n    name === 'bool' ||\r\n    name === 'function' ||\r\n    name === 'string' ||\r\n    name === 'tuple' ||\r\n    bytesRegex.test(name) ||\r\n    integerRegex.test(name) ||\r\n    protectedKeywordsRegex.test(name)\r\n  )\r\n}\r\n\r\nexport function isValidDataLocation(\r\n  type: string,\r\n  isArray: boolean,\r\n): type is Exclude<\r\n  AbiType,\r\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\r\n> {\r\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}