{"ast":null,"code":"import { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    const match = execStructSignature(signature);\n    if (!match) throw new InvalidSignatureError({\n      signature,\n      type: 'struct'\n    });\n    const properties = match.properties.split(';');\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct'\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new InvalidStructSignatureError({\n      signature\n    });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i];\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!match?.type) throw new InvalidAbiTypeParameterError({\n        abiParameter\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({\n          type\n        });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))\n        });\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new UnknownTypeError({\n          type\n        });\n      }\n    }\n  }\n  return components;\n}","map":{"version":3,"names":["execTyped","isTupleRegex","UnknownTypeError","InvalidAbiTypeParameterError","InvalidSignatureError","InvalidStructSignatureError","CircularReferenceError","execStructSignature","isStructSignature","isSolidityType","parseAbiParameter","parseStructs","signatures","shallowStructs","signaturesLength","length","i","signature","match","type","properties","split","components","propertiesLength","k","property","trimmed","trim","abiParameter","push","name","resolvedStructs","entries","Object","entriesLength","parameters","resolveStructs","typeWithoutTupleRegex","abiParameters","structs","ancestors","Set","isTuple","test","array","has"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\Artica\\artica-repo\\frontend\\node_modules\\abitype\\src\\human-readable\\runtime\\structs.ts"],"sourcesContent":["import type { AbiParameter } from '../../abi.js'\r\nimport { execTyped, isTupleRegex } from '../../regex.js'\r\nimport { UnknownTypeError } from '../errors/abiItem.js'\r\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\r\nimport {\r\n  InvalidSignatureError,\r\n  InvalidStructSignatureError,\r\n} from '../errors/signature.js'\r\nimport { CircularReferenceError } from '../errors/struct.js'\r\nimport type { StructLookup } from '../types/structs.js'\r\nimport { execStructSignature, isStructSignature } from './signatures.js'\r\nimport { isSolidityType, parseAbiParameter } from './utils.js'\r\n\r\nexport function parseStructs(signatures: readonly string[]) {\r\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\r\n  const shallowStructs: StructLookup = {}\r\n  const signaturesLength = signatures.length\r\n  for (let i = 0; i < signaturesLength; i++) {\r\n    const signature = signatures[i]!\r\n    if (!isStructSignature(signature)) continue\r\n\r\n    const match = execStructSignature(signature)\r\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\r\n\r\n    const properties = match.properties.split(';')\r\n\r\n    const components: AbiParameter[] = []\r\n    const propertiesLength = properties.length\r\n    for (let k = 0; k < propertiesLength; k++) {\r\n      const property = properties[k]!\r\n      const trimmed = property.trim()\r\n      if (!trimmed) continue\r\n      const abiParameter = parseAbiParameter(trimmed, {\r\n        type: 'struct',\r\n      })\r\n      components.push(abiParameter)\r\n    }\r\n\r\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\r\n    shallowStructs[match.name] = components\r\n  }\r\n\r\n  // Resolve nested structs inside each parameter\r\n  const resolvedStructs: StructLookup = {}\r\n  const entries = Object.entries(shallowStructs)\r\n  const entriesLength = entries.length\r\n  for (let i = 0; i < entriesLength; i++) {\r\n    const [name, parameters] = entries[i]!\r\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\r\n  }\r\n\r\n  return resolvedStructs\r\n}\r\n\r\nconst typeWithoutTupleRegex =\r\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\r\n\r\nfunction resolveStructs(\r\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\r\n  structs: StructLookup,\r\n  ancestors = new Set<string>(),\r\n) {\r\n  const components: AbiParameter[] = []\r\n  const length = abiParameters.length\r\n  for (let i = 0; i < length; i++) {\r\n    const abiParameter = abiParameters[i]!\r\n    const isTuple = isTupleRegex.test(abiParameter.type)\r\n    if (isTuple) components.push(abiParameter)\r\n    else {\r\n      const match = execTyped<{ array?: string; type: string }>(\r\n        typeWithoutTupleRegex,\r\n        abiParameter.type,\r\n      )\r\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\r\n\r\n      const { array, type } = match\r\n      if (type in structs) {\r\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\r\n\r\n        components.push({\r\n          ...abiParameter,\r\n          type: `tuple${array ?? ''}`,\r\n          components: resolveStructs(\r\n            structs[type] ?? [],\r\n            structs,\r\n            new Set([...ancestors, type]),\r\n          ),\r\n        })\r\n      } else {\r\n        if (isSolidityType(type)) components.push(abiParameter)\r\n        else throw new UnknownTypeError({ type })\r\n      }\r\n    }\r\n  }\r\n\r\n  return components\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}