{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseAbiParameters = void 0;\nconst index_js_1 = require(\"../index.js\");\nconst signatures_js_1 = require(\"./runtime/signatures.js\");\nconst structs_js_1 = require(\"./runtime/structs.js\");\nconst utils_js_1 = require(\"./runtime/utils.js\");\nconst utils_js_2 = require(\"./runtime/utils.js\");\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === 'string') {\n    const parameters = (0, utils_js_1.splitParameters)(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], {\n        modifiers: signatures_js_1.modifiers\n      }));\n    }\n  } else {\n    const structs = (0, structs_js_1.parseStructs)(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if ((0, signatures_js_1.isStructSignature)(signature)) continue;\n      const parameters = (0, utils_js_1.splitParameters)(signature);\n      const length = parameters.length;\n      for (let k = 0; k < length; k++) {\n        abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], {\n          modifiers: signatures_js_1.modifiers,\n          structs\n        }));\n      }\n    }\n  }\n  if (abiParameters.length === 0) throw new index_js_1.InvalidAbiParametersError({\n    params\n  });\n  return abiParameters;\n}\nexports.parseAbiParameters = parseAbiParameters;","map":{"version":3,"names":["index_js_1","require","signatures_js_1","structs_js_1","utils_js_1","utils_js_2","parseAbiParameters","params","abiParameters","parameters","splitParameters","length","i","push","parseAbiParameter","modifiers","structs","parseStructs","signature","isStructSignature","k","InvalidAbiParametersError","exports"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\Artica\\artica-repo\\frontend\\node_modules\\abitype\\src\\human-readable\\parseAbiParameters.ts"],"sourcesContent":["import type { AbiParameter } from '../abi.js'\r\nimport { InvalidAbiParametersError } from '../index.js'\r\nimport type { Narrow } from '../narrow.js'\r\nimport type { Error, Filter } from '../types.js'\r\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\r\nimport { parseStructs } from './runtime/structs.js'\r\nimport { splitParameters } from './runtime/utils.js'\r\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\r\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\r\nimport type { ParseStructs } from './types/structs.js'\r\nimport type { SplitParameters } from './types/utils.js'\r\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\r\n\r\n/**\r\n * Parses human-readable ABI parameters into {@link AbiParameter}s\r\n *\r\n * @param TParams - Human-readable ABI parameters\r\n * @returns Parsed {@link AbiParameter}s\r\n *\r\n * @example\r\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\r\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\r\n *\r\n * @example\r\n * type Result = ParseAbiParameters<\r\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   ['Baz bar', 'struct Baz { string name; }']\r\n * >\r\n */\r\nexport type ParseAbiParameters<\r\n  TParams extends string | readonly string[] | readonly unknown[],\r\n> =\r\n  | (TParams extends string\r\n      ? TParams extends ''\r\n        ? never\r\n        : string extends TParams\r\n        ? readonly AbiParameter[]\r\n        : ParseAbiParameters_<SplitParameters<TParams>, { Modifier: Modifier }>\r\n      : never)\r\n  | (TParams extends readonly string[]\r\n      ? string[] extends TParams\r\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\r\n        : ParseStructs<TParams> extends infer Structs\r\n        ? {\r\n            [K in keyof TParams]: TParams[K] extends string\r\n              ? IsStructSignature<TParams[K]> extends true\r\n                ? never\r\n                : ParseAbiParameters_<\r\n                    SplitParameters<TParams[K]>,\r\n                    { Modifier: Modifier; Structs: Structs }\r\n                  >\r\n              : never\r\n          } extends infer Mapped extends readonly unknown[]\r\n          ? Filter<Mapped, never>[0] extends infer Result\r\n            ? Result extends undefined\r\n              ? never\r\n              : Result\r\n            : never\r\n          : never\r\n        : never\r\n      : never)\r\n\r\n/**\r\n * Parses human-readable ABI parameters into {@link AbiParameter}s\r\n *\r\n * @param params - Human-readable ABI parameters\r\n * @returns Parsed {@link AbiParameter}s\r\n *\r\n * @example\r\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\r\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\r\n *\r\n * @example\r\n * const abiParameters = parseAbiParameters([\r\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   'Baz bar',\r\n *   'struct Baz { string name; }',\r\n * ])\r\n */\r\nexport function parseAbiParameters<\r\n  TParams extends string | readonly string[] | readonly unknown[],\r\n>(\r\n  params: Narrow<TParams> &\r\n    (\r\n      | (TParams extends string\r\n          ? TParams extends ''\r\n            ? Error<'Empty string is not allowed.'>\r\n            : unknown\r\n          : never)\r\n      | (TParams extends readonly string[]\r\n          ? TParams extends readonly [] // empty array\r\n            ? Error<'At least one parameter required.'>\r\n            : string[] extends TParams\r\n            ? unknown\r\n            : unknown // TODO: Validate param string\r\n          : never)\r\n    ),\r\n): ParseAbiParameters<TParams> {\r\n  const abiParameters: AbiParameter[] = []\r\n  if (typeof params === 'string') {\r\n    const parameters = splitParameters(params)\r\n    const length = parameters.length\r\n    for (let i = 0; i < length; i++) {\r\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\r\n    }\r\n  } else {\r\n    const structs = parseStructs(params as readonly string[])\r\n    const length = params.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const signature = (params as readonly string[])[i]!\r\n      if (isStructSignature(signature)) continue\r\n      const parameters = splitParameters(signature)\r\n      const length = parameters.length\r\n      for (let k = 0; k < length; k++) {\r\n        abiParameters.push(\r\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (abiParameters.length === 0)\r\n    throw new InvalidAbiParametersError({ params })\r\n\r\n  return abiParameters as ParseAbiParameters<TParams>\r\n}\r\n"],"mappings":";;;;;;AACA,MAAAA,UAAA,GAAAC,OAAA;AAGA,MAAAC,eAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AACA,MAAAI,UAAA,GAAAJ,OAAA;AAwEA,SAAgBK,kBAAkBA,CAGhCC,MAcG;EAEH,MAAMC,aAAa,GAAmB,EAAE;EACxC,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAME,UAAU,GAAG,IAAAL,UAAA,CAAAM,eAAe,EAACH,MAAM,CAAC;IAC1C,MAAMI,MAAM,GAAGF,UAAU,CAACE,MAAM;IAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/BJ,aAAa,CAACK,IAAI,CAAC,IAAAR,UAAA,CAAAS,iBAAkB,EAACL,UAAU,CAACG,CAAC,CAAE,EAAE;QAAEG,SAAS,EAATb,eAAA,CAAAa;MAAS,CAAE,CAAC,CAAC;;GAExE,MAAM;IACL,MAAMC,OAAO,GAAG,IAAAb,YAAA,CAAAc,YAAY,EAACV,MAA2B,CAAC;IACzD,MAAMI,MAAM,GAAGJ,MAAM,CAACI,MAAgB;IACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,MAAMM,SAAS,GAAIX,MAA4B,CAACK,CAAC,CAAE;MACnD,IAAI,IAAAV,eAAA,CAAAiB,iBAAiB,EAACD,SAAS,CAAC,EAAE;MAClC,MAAMT,UAAU,GAAG,IAAAL,UAAA,CAAAM,eAAe,EAACQ,SAAS,CAAC;MAC7C,MAAMP,MAAM,GAAGF,UAAU,CAACE,MAAM;MAChC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,EAAES,CAAC,EAAE,EAAE;QAC/BZ,aAAa,CAACK,IAAI,CAChB,IAAAR,UAAA,CAAAS,iBAAkB,EAACL,UAAU,CAACW,CAAC,CAAE,EAAE;UAAEL,SAAS,EAATb,eAAA,CAAAa,SAAS;UAAEC;QAAO,CAAE,CAAC,CAC3D;;;;EAKP,IAAIR,aAAa,CAACG,MAAM,KAAK,CAAC,EAC5B,MAAM,IAAIX,UAAA,CAAAqB,yBAAyB,CAAC;IAAEd;EAAM,CAAE,CAAC;EAEjD,OAAOC,aAA4C;AACrD;AA9CAc,OAAA,CAAAhB,kBAAA,GAAAA,kBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}