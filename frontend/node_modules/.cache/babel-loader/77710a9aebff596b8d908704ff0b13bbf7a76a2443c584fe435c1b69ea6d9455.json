{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseAbiItem = void 0;\nconst index_js_1 = require(\"../index.js\");\nconst signatures_js_1 = require(\"./runtime/signatures.js\");\nconst structs_js_1 = require(\"./runtime/structs.js\");\nconst utils_js_1 = require(\"./runtime/utils.js\");\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === 'string') abiItem = (0, utils_js_1.parseSignature)(signature);else {\n    const structs = (0, structs_js_1.parseStructs)(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if ((0, signatures_js_1.isStructSignature)(signature_)) continue;\n      abiItem = (0, utils_js_1.parseSignature)(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem) throw new index_js_1.InvalidAbiItemError({\n    signature\n  });\n  return abiItem;\n}\nexports.parseAbiItem = parseAbiItem;","map":{"version":3,"names":["index_js_1","require","signatures_js_1","structs_js_1","utils_js_1","parseAbiItem","signature","abiItem","parseSignature","structs","parseStructs","length","i","signature_","isStructSignature","InvalidAbiItemError","exports"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\Artica\\artica-repo\\frontend\\node_modules\\abitype\\src\\human-readable\\parseAbiItem.ts"],"sourcesContent":["import type { Abi } from '../abi.js'\r\nimport { InvalidAbiItemError } from '../index.js'\r\nimport type { Narrow } from '../narrow.js'\r\nimport type { Error, Filter } from '../types.js'\r\nimport { isStructSignature } from './runtime/signatures.js'\r\nimport { parseStructs } from './runtime/structs.js'\r\nimport { parseSignature } from './runtime/utils.js'\r\nimport type { Signature, Signatures } from './types/signatures.js'\r\nimport type { ParseStructs } from './types/structs.js'\r\nimport type { ParseSignature } from './types/utils.js'\r\n\r\n/**\r\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\r\n *\r\n * @param TSignature - Human-readable ABI item\r\n * @returns Parsed {@link Abi} item\r\n *\r\n * @example\r\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\r\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\r\n *\r\n * @example\r\n * type Result = ParseAbiItem<\r\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\r\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\r\n * >\r\n */\r\nexport type ParseAbiItem<\r\n  TSignature extends string | readonly string[] | readonly unknown[],\r\n> =\r\n  | (TSignature extends string\r\n      ? string extends TSignature\r\n        ? Abi[number]\r\n        : TSignature extends Signature<TSignature> // Validate signature\r\n        ? ParseSignature<TSignature>\r\n        : never\r\n      : never)\r\n  | (TSignature extends readonly string[]\r\n      ? string[] extends TSignature\r\n        ? Abi[number] // Return generic Abi item since type was no inferrable\r\n        : TSignature extends Signatures<TSignature> // Validate signature\r\n        ? ParseStructs<TSignature> extends infer Structs\r\n          ? {\r\n              [K in keyof TSignature]: ParseSignature<\r\n                TSignature[K] extends string ? TSignature[K] : never,\r\n                Structs\r\n              >\r\n            } extends infer Mapped extends readonly unknown[]\r\n            ? // Filter out `never` since those are structs\r\n              Filter<Mapped, never>[0] extends infer Result\r\n              ? Result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\r\n                ? never\r\n                : Result\r\n              : never\r\n            : never\r\n          : never\r\n        : never\r\n      : never)\r\n\r\n/**\r\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\r\n *\r\n * @param signature - Human-readable ABI item\r\n * @returns Parsed {@link Abi} item\r\n *\r\n * @example\r\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\r\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\r\n *\r\n * @example\r\n * const abiItem = parseAbiItem([\r\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\r\n *   'function foo(Baz bar) view returns (string)',\r\n *   'struct Baz { string name; }',\r\n * ])\r\n */\r\nexport function parseAbiItem<\r\n  TSignature extends string | readonly string[] | readonly unknown[],\r\n>(\r\n  signature: Narrow<TSignature> &\r\n    (\r\n      | (TSignature extends string\r\n          ? string extends TSignature\r\n            ? unknown\r\n            : Signature<TSignature>\r\n          : never)\r\n      | (TSignature extends readonly string[]\r\n          ? TSignature extends readonly [] // empty array\r\n            ? Error<'At least one signature required.'>\r\n            : string[] extends TSignature\r\n            ? unknown\r\n            : Signatures<TSignature>\r\n          : never)\r\n    ),\r\n): ParseAbiItem<TSignature> {\r\n  let abiItem\r\n  if (typeof signature === 'string')\r\n    abiItem = parseSignature(signature) as ParseAbiItem<TSignature>\r\n  else {\r\n    const structs = parseStructs(signature as readonly string[])\r\n    const length = signature.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const signature_ = (signature as readonly string[])[i]!\r\n      if (isStructSignature(signature_)) continue\r\n      abiItem = parseSignature(signature_, structs)\r\n      break\r\n    }\r\n  }\r\n\r\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\r\n  return abiItem as ParseAbiItem<TSignature>\r\n}\r\n"],"mappings":";;;;;;AACA,MAAAA,UAAA,GAAAC,OAAA;AAGA,MAAAC,eAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AAsEA,SAAgBI,YAAYA,CAG1BC,SAcG;EAEH,IAAIC,OAAO;EACX,IAAI,OAAOD,SAAS,KAAK,QAAQ,EAC/BC,OAAO,GAAG,IAAAH,UAAA,CAAAI,cAAc,EAACF,SAAS,CAA6B,MAC5D;IACH,MAAMG,OAAO,GAAG,IAAAN,YAAA,CAAAO,YAAY,EAACJ,SAA8B,CAAC;IAC5D,MAAMK,MAAM,GAAGL,SAAS,CAACK,MAAgB;IACzC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,MAAMC,UAAU,GAAIP,SAA+B,CAACM,CAAC,CAAE;MACvD,IAAI,IAAAV,eAAA,CAAAY,iBAAiB,EAACD,UAAU,CAAC,EAAE;MACnCN,OAAO,GAAG,IAAAH,UAAA,CAAAI,cAAc,EAACK,UAAU,EAAEJ,OAAO,CAAC;MAC7C;;;EAIJ,IAAI,CAACF,OAAO,EAAE,MAAM,IAAIP,UAAA,CAAAe,mBAAmB,CAAC;IAAET;EAAS,CAAE,CAAC;EAC1D,OAAOC,OAAmC;AAC5C;AAnCAS,OAAA,CAAAX,YAAA,GAAAA,YAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}