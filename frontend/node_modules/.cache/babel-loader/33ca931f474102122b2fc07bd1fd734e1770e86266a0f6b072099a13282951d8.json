{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseAbiParameter = void 0;\nconst index_js_1 = require(\"../index.js\");\nconst signatures_js_1 = require(\"./runtime/signatures.js\");\nconst structs_js_1 = require(\"./runtime/structs.js\");\nconst utils_js_1 = require(\"./runtime/utils.js\");\nfunction parseAbiParameter(param) {\n  let abiParameter;\n  if (typeof param === 'string') abiParameter = (0, utils_js_1.parseAbiParameter)(param, {\n    modifiers: signatures_js_1.modifiers\n  });else {\n    const structs = (0, structs_js_1.parseStructs)(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if ((0, signatures_js_1.isStructSignature)(signature)) continue;\n      abiParameter = (0, utils_js_1.parseAbiParameter)(signature, {\n        modifiers: signatures_js_1.modifiers,\n        structs\n      });\n      break;\n    }\n  }\n  if (!abiParameter) throw new index_js_1.InvalidAbiParameterError({\n    param\n  });\n  return abiParameter;\n}\nexports.parseAbiParameter = parseAbiParameter;","map":{"version":3,"names":["index_js_1","require","signatures_js_1","structs_js_1","utils_js_1","parseAbiParameter","param","abiParameter","modifiers","structs","parseStructs","length","i","signature","isStructSignature","InvalidAbiParameterError","exports"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\Artica\\artica-repo\\frontend\\node_modules\\abitype\\src\\human-readable\\parseAbiParameter.ts"],"sourcesContent":["import type { AbiParameter } from '../abi.js'\r\nimport { InvalidAbiParameterError } from '../index.js'\r\nimport type { Narrow } from '../narrow.js'\r\nimport type { Error, Filter } from '../types.js'\r\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\r\nimport { parseStructs } from './runtime/structs.js'\r\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\r\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\r\nimport type { ParseStructs } from './types/structs.js'\r\nimport type { ParseAbiParameter as ParseAbiParameter_ } from './types/utils.js'\r\n\r\n/**\r\n * Parses human-readable ABI parameter into {@link AbiParameter}\r\n *\r\n * @param TParam - Human-readable ABI parameter\r\n * @returns Parsed {@link AbiParameter}\r\n *\r\n * @example\r\n * type Result = ParseAbiParameter<'address from'>\r\n * //   ^? type Result = { type: \"address\"; name: \"from\"; }\r\n *\r\n * @example\r\n * type Result = ParseAbiParameter<\r\n *   // ^? type Result = { type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   ['Baz bar', 'struct Baz { string name; }']\r\n * >\r\n */\r\nexport type ParseAbiParameter<\r\n  TParam extends string | readonly string[] | readonly unknown[],\r\n> =\r\n  | (TParam extends string\r\n      ? TParam extends ''\r\n        ? never\r\n        : string extends TParam\r\n        ? AbiParameter\r\n        : ParseAbiParameter_<TParam, { Modifier: Modifier }>\r\n      : never)\r\n  | (TParam extends readonly string[]\r\n      ? string[] extends TParam\r\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\r\n        : ParseStructs<TParam> extends infer Structs\r\n        ? {\r\n            [K in keyof TParam]: TParam[K] extends string\r\n              ? IsStructSignature<TParam[K]> extends true\r\n                ? never\r\n                : ParseAbiParameter_<\r\n                    TParam[K],\r\n                    { Modifier: Modifier; Structs: Structs }\r\n                  >\r\n              : never\r\n          } extends infer Mapped extends readonly unknown[]\r\n          ? Filter<Mapped, never>[0] extends infer Result\r\n            ? Result extends undefined\r\n              ? never\r\n              : Result\r\n            : never\r\n          : never\r\n        : never\r\n      : never)\r\n\r\n/**\r\n * Parses human-readable ABI parameter into {@link AbiParameter}\r\n *\r\n * @param param - Human-readable ABI parameter\r\n * @returns Parsed {@link AbiParameter}\r\n *\r\n * @example\r\n * const abiParameter = parseAbiParameter('address from')\r\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\r\n *\r\n * @example\r\n * const abiParameter = parseAbiParameter([\r\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\r\n *   'Baz bar',\r\n *   'struct Baz { string name; }',\r\n * ])\r\n */\r\nexport function parseAbiParameter<\r\n  TParam extends string | readonly string[] | readonly unknown[],\r\n>(\r\n  param: Narrow<TParam> &\r\n    (\r\n      | (TParam extends string\r\n          ? TParam extends ''\r\n            ? Error<'Empty string is not allowed.'>\r\n            : unknown\r\n          : never)\r\n      | (TParam extends readonly string[]\r\n          ? TParam extends readonly [] // empty array\r\n            ? Error<'At least one parameter required.'>\r\n            : string[] extends TParam\r\n            ? unknown\r\n            : unknown // TODO: Validate param string\r\n          : never)\r\n    ),\r\n): ParseAbiParameter<TParam> {\r\n  let abiParameter\r\n  if (typeof param === 'string')\r\n    abiParameter = parseAbiParameter_(param, {\r\n      modifiers,\r\n    }) as ParseAbiParameter<TParam>\r\n  else {\r\n    const structs = parseStructs(param as readonly string[])\r\n    const length = param.length as number\r\n    for (let i = 0; i < length; i++) {\r\n      const signature = (param as readonly string[])[i]!\r\n      if (isStructSignature(signature)) continue\r\n      abiParameter = parseAbiParameter_(signature, { modifiers, structs })\r\n      break\r\n    }\r\n  }\r\n\r\n  if (!abiParameter) throw new InvalidAbiParameterError({ param })\r\n\r\n  return abiParameter as ParseAbiParameter<TParam>\r\n}\r\n"],"mappings":";;;;;;AACA,MAAAA,UAAA,GAAAC,OAAA;AAGA,MAAAC,eAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AAuEA,SAAgBI,iBAAiBA,CAG/BC,KAcG;EAEH,IAAIC,YAAY;EAChB,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAC3BC,YAAY,GAAG,IAAAH,UAAA,CAAAC,iBAAkB,EAACC,KAAK,EAAE;IACvCE,SAAS,EAATN,eAAA,CAAAM;GACD,CAA8B,MAC5B;IACH,MAAMC,OAAO,GAAG,IAAAN,YAAA,CAAAO,YAAY,EAACJ,KAA0B,CAAC;IACxD,MAAMK,MAAM,GAAGL,KAAK,CAACK,MAAgB;IACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,MAAMC,SAAS,GAAIP,KAA2B,CAACM,CAAC,CAAE;MAClD,IAAI,IAAAV,eAAA,CAAAY,iBAAiB,EAACD,SAAS,CAAC,EAAE;MAClCN,YAAY,GAAG,IAAAH,UAAA,CAAAC,iBAAkB,EAACQ,SAAS,EAAE;QAAEL,SAAS,EAATN,eAAA,CAAAM,SAAS;QAAEC;MAAO,CAAE,CAAC;MACpE;;;EAIJ,IAAI,CAACF,YAAY,EAAE,MAAM,IAAIP,UAAA,CAAAe,wBAAwB,CAAC;IAAET;EAAK,CAAE,CAAC;EAEhE,OAAOC,YAAyC;AAClD;AAtCAS,OAAA,CAAAX,iBAAA,GAAAA,iBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}