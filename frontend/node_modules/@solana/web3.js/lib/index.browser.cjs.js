'use strict';

var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var buffer = require('buffer');
var ed25519 = require('@noble/curves/ed25519');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var BN = require('bn.js');
var bs58 = require('bs58');
var sha256 = require('@noble/hashes/sha256');
var borsh = require('borsh');
var BufferLayout = require('@solana/buffer-layout');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var bigintBuffer = require('bigint-buffer');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var _typeof = require('@babel/runtime/helpers/typeof');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var superstruct = require('superstruct');
var RpcClient = require('jayson/lib/client/browser');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
var _get = require('@babel/runtime/helpers/get');
var RpcWebSocketCommonClient = require('rpc-websockets/dist/lib/client');
var createRpc = require('rpc-websockets/dist/lib/client/websocket.browser');
var sha3 = require('@noble/hashes/sha3');
var secp256k1 = require('@noble/curves/secp256k1');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var _classCallCheck__default = /*#__PURE__*/_interopDefaultCompat(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultCompat(_createClass);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultCompat(_asyncToGenerator);
var _inherits__default = /*#__PURE__*/_interopDefaultCompat(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultCompat(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultCompat(_getPrototypeOf);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultCompat(_regeneratorRuntime);
var BN__default = /*#__PURE__*/_interopDefaultCompat(BN);
var bs58__default = /*#__PURE__*/_interopDefaultCompat(bs58);
var BufferLayout__namespace = /*#__PURE__*/_interopNamespaceCompat(BufferLayout);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultCompat(_slicedToArray);
var _defineProperty__default = /*#__PURE__*/_interopDefaultCompat(_defineProperty);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultCompat(_toConsumableArray);
var _typeof__default = /*#__PURE__*/_interopDefaultCompat(_typeof);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultCompat(_objectWithoutProperties);
var RpcClient__default = /*#__PURE__*/_interopDefaultCompat(RpcClient);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultCompat(_wrapNativeSuper);
var _get__default = /*#__PURE__*/_interopDefaultCompat(_get);
var RpcWebSocketCommonClient__default = /*#__PURE__*/_interopDefaultCompat(RpcWebSocketCommonClient);
var createRpc__default = /*#__PURE__*/_interopDefaultCompat(createRpc);

/**
 * A 64 byte secret key, the first 32 bytes of which is the
 * private scalar and the last 32 bytes is the public key.
 * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
 */

/**
 * Ed25519 Keypair
 */

var generatePrivateKey = ed25519.ed25519.utils.randomPrivateKey;
var generateKeypair = function generateKeypair() {
  var privateScalar = ed25519.ed25519.utils.randomPrivateKey();
  var publicKey = getPublicKey(privateScalar);
  var secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey: publicKey,
    secretKey: secretKey
  };
};
var getPublicKey = ed25519.ed25519.getPublicKey;
function isOnCurve(publicKey) {
  try {
    ed25519.ed25519.ExtendedPoint.fromHex(publicKey);
    return true;
  } catch (_unused) {
    return false;
  }
}
var sign = function sign(message, secretKey) {
  return ed25519.ed25519.sign(message, secretKey.slice(0, 32));
};
var verify = ed25519.ed25519.verify;

var toBuffer = function toBuffer(arr) {
  if (buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer.Buffer.from(arr);
  }
};

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf__default.default(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default.default(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default.default(this, result); }; }
function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Class wrapping a plain object
var Struct = /*#__PURE__*/function () {
  function Struct(properties) {
    _classCallCheck__default.default(this, Struct);
    Object.assign(this, properties);
  }
  _createClass__default.default(Struct, [{
    key: "encode",
    value: function encode() {
      return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA, this));
    }
  }], [{
    key: "decode",
    value: function decode(data) {
      return borsh.deserialize(SOLANA_SCHEMA, this, data);
    }
  }, {
    key: "decodeUnchecked",
    value: function decodeUnchecked(data) {
      return borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);
    }
  }]);
  return Struct;
}();

// Class representing a Rust-compatible enum, since enums are only strings or
// numbers in pure JS
var Enum = /*#__PURE__*/function (_Struct) {
  _inherits__default.default(Enum, _Struct);
  var _super = _createSuper$4(Enum);
  function Enum(properties) {
    var _this;
    _classCallCheck__default.default(this, Enum);
    _this = _super.call(this, properties);
    _this["enum"] = '';
    if (Object.keys(properties).length !== 1) {
      throw new Error('Enum can only take single value');
    }
    Object.keys(properties).map(function (key) {
      _this["enum"] = key;
    });
    return _this;
  }
  return _createClass__default.default(Enum);
}(Struct);
var SOLANA_SCHEMA = new Map();

var _Symbol$toStringTag;
function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default.default(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default.default(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default.default(this, result); }; }
function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Maximum length of derived pubkey seed
 */
var MAX_SEED_LENGTH = 32;

/**
 * Size of public key in bytes
 */
var PUBLIC_KEY_LENGTH = 32;

/**
 * Value to be converted into public key
 */

/**
 * JSON object representation of PublicKey class
 */

function isPublicKeyData(value) {
  return value._bn !== undefined;
}

// local counter used by PublicKey.unique()
var uniquePublicKeyCounter = 1;

/**
 * A public key
 */
_Symbol$toStringTag = Symbol.toStringTag;
var PublicKey = /*#__PURE__*/function (_Struct) {
  _inherits__default.default(PublicKey, _Struct);
  var _super = _createSuper$3(PublicKey);
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  function PublicKey(value) {
    var _this;
    _classCallCheck__default.default(this, PublicKey);
    _this = _super.call(this, {});
    /** @internal */
    _this._bn = void 0;
    if (isPublicKeyData(value)) {
      _this._bn = value._bn;
    } else {
      if (typeof value === 'string') {
        // assume base 58 encoding by default
        var decoded = bs58__default.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error("Invalid public key input");
        }
        _this._bn = new BN__default.default(decoded);
      } else {
        _this._bn = new BN__default.default(value);
      }
      if (_this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error("Invalid public key input");
      }
    }
    return _this;
  }

  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  _createClass__default.default(PublicKey, [{
    key: "equals",
    value:
    /**
     * Checks if two publicKeys are equal
     */
    function equals(publicKey) {
      return this._bn.eq(publicKey._bn);
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toBase58",
    value: function toBase58() {
      return bs58__default.default.encode(this.toBytes());
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toBase58();
    }

    /**
     * Return the byte array representation of the public key in big endian
     */
  }, {
    key: "toBytes",
    value: function toBytes() {
      var buf = this.toBuffer();
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }

    /**
     * Return the Buffer representation of the public key in big endian
     */
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      var b = this._bn.toArrayLike(buffer.Buffer);
      if (b.length === PUBLIC_KEY_LENGTH) {
        return b;
      }
      var zeroPad = buffer.Buffer.alloc(32);
      b.copy(zeroPad, 32 - b.length);
      return zeroPad;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "PublicKey(".concat(this.toString(), ")");
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toString",
    value: function toString() {
      return this.toBase58();
    }

    /**
     * Derive a public key from another key, a seed, and a program ID.
     * The program ID will also serve as the owner of the public key, giving
     * it permission to write data to the account.
     */
    /* eslint-disable require-await */
  }], [{
    key: "unique",
    value: function unique() {
      var key = new PublicKey(uniquePublicKeyCounter);
      uniquePublicKeyCounter += 1;
      return new PublicKey(key.toBuffer());
    }

    /**
     * Default public key value. The base58-encoded string representation is all ones (as seen below)
     * The underlying BN number is 32 bytes that are all zeros
     */
  }, {
    key: "createWithSeed",
    value: function () {
      var _createWithSeed = _asyncToGenerator__default.default( /*#__PURE__*/_regeneratorRuntime__default.default.mark(function _callee(fromPublicKey, seed, programId) {
        var buffer$1, publicKeyBytes;
        return _regeneratorRuntime__default.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
              publicKeyBytes = sha256.sha256(buffer$1);
              return _context.abrupt("return", new PublicKey(publicKeyBytes));
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function createWithSeed(_x, _x2, _x3) {
        return _createWithSeed.apply(this, arguments);
      }
      return createWithSeed;
    }()
    /**
     * Derive a program address from seeds and a program ID.
     */
    /* eslint-disable require-await */
  }, {
    key: "createProgramAddressSync",
    value: function createProgramAddressSync(seeds, programId) {
      var buffer$1 = buffer.Buffer.alloc(0);
      seeds.forEach(function (seed) {
        if (seed.length > MAX_SEED_LENGTH) {
          throw new TypeError("Max seed length exceeded");
        }
        buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed)]);
      });
      buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from('ProgramDerivedAddress')]);
      var publicKeyBytes = sha256.sha256(buffer$1);
      if (isOnCurve(publicKeyBytes)) {
        throw new Error("Invalid seeds, address must fall off the curve");
      }
      return new PublicKey(publicKeyBytes);
    }

    /**
     * Async version of createProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link createProgramAddressSync} instead
     */
   